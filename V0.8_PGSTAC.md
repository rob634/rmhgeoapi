```markdown
# TiTiler-pgSTAC Search Pattern Guide

## Core Concept: Registered Searches as Virtual Collections

The `/searches` endpoint lets you **save a query as a short ID** instead of passing complex JSON in every tile request.

```bash
# Instead of this (uncacheable, ugly):
/mosaic/tiles/{z}/{x}/{y}?query={"collections":["floods"],"datetime":"2020-01-01/2020-12-31","bbox":[...]}

# Do this:
POST /searches/register
Body: {"collections": ["floods"], "datetime": "2020-01-01/2020-12-31"}
Response: {"id": "abc123"}

GET /searches/abc123/tiles/{z}/{x}/{y}
```

**Why this matters:**
- Query executed once, results cached
- Tile URLs are CDN-cacheable
- Clean URLs for users
- Search IDs are deterministic (same query = same ID)

---

## Three Ways to Use Searches

### 1. Mosaic Rendering (Composite View)
Returns a **single mosaic tile** blending all matching items:

```bash
POST /searches/register
{
  "collections": ["flood_extents"],
  "datetime": "2023-01-01/2023-12-31",
  "sortby": [{"field": "datetime", "direction": "desc"}]
}
→ {"id": "floods2023"}

# Tiles show composite (latest on top)
GET /searches/floods2023/tiles/{z}/{x}/{y}
```

**Use for:** "Latest cloud-free pixel", multi-sensor fusion, overlapping datasets

**Not good for:** Frame-by-frame animation

### 2. Item Enumeration (Animation/Iteration)
Get the **list of matching items**, then tile them individually:

```bash
# Register broad search
POST /searches/register
{
  "collections": ["flood_extents"],
  "datetime": "2023-01-01/2023-12-31",
  "sortby": [{"field": "datetime", "direction": "asc"}]
}
→ {"id": "floods2023"}

# Get item list
GET /searches/floods2023/list
→ [
  {"id": "flood_jan", "properties": {"datetime": "2023-01-15"}},
  {"id": "flood_feb", "properties": {"datetime": "2023-02-15"}},
  ...
]

# Tile individual items for animation
GET /collections/flood_extents/items/flood_jan/tiles/{z}/{x}/{y}
GET /collections/flood_extents/items/flood_feb/tiles/{z}/{x}/{y}
```

**Use for:** Time-series animation, discrete frames, ordered iteration

### 3. Dynamic Filtering (Runtime Parameters)
Combine registered search with additional filters at tile-request time:

```bash
# Registered: broad category
POST /searches/register
{
  "collections": ["fathom"],
  "query": {"flood_type": {"eq": "fluvial"}}
}
→ {"id": "fluvial_floods"}

# Runtime: user-specific filter
GET /searches/fluvial_floods/tiles/{z}/{x}/{y}?filter={"op":"=","args":[{"property":"return_period"},100]}

# Add visualization
GET /searches/fluvial_floods/tiles/{z}/{x}/{y}?filter={...}&rescale=0,5&colormap_name=blues
```

**Use for:** Large catalogs with many dimensions, user-driven filtering

---

## Query vs Visualization Parameters

### Query Parameters (Locked at Registration)
What items to include:

```json
{
  "collections": ["my_collection"],
  "datetime": "2020-01-01/2020-12-31",
  "bbox": [-180, -90, 180, 90],
  "query": {
    "flood_type": {"eq": "fluvial"},
    "return_period": {"gte": 100}
  },
  "sortby": [{"field": "datetime", "direction": "asc"}],
  "limit": 100
}
```

### Visualization Parameters (Per Tile Request)
How to render:

```bash
# Single-band with colormap
?assets=B04&rescale=0,3000&colormap_name=viridis

# RGB composite
?assets=B04,B03,B02&rescale=0,3000,0,3000,0,3000

# Expression (NDVI)
?expression=(B08-B04)/(B08%2BB04)&rescale=-1,1&colormap_name=rdylgn

# Transparency
?nodata=0&return_mask=true

# Resampling
?resampling_method=bilinear
```

**You can override at tile time** even if baked into registration.

---

## Pattern: Large Multi-Dimensional Catalogs

### Example: FATHOM Flood Data

**Dimensions:**
- Flood type: Fluvial, Pluvial, Coastal
- Defense: Defended, Undefended
- Return period: 10, 20, 50, 100, 200, 500, 1000 years
- Scenario: Historical, RCP4.5, RCP8.5
- Time period: Baseline, 2030s, 2050s, 2080s

### Strategy: Register Major Categories, Filter the Rest

```python
# At deployment: register base searches (5-10 total)
REGISTERED_SEARCHES = {
    "fluvial_undefended": {
        "collections": ["fathom"],
        "query": {
            "flood_type": {"eq": "fluvial"},
            "defense": {"eq": "undefended"}
        }
    },
    "fluvial_defended": {
        "collections": ["fathom"],
        "query": {
            "flood_type": {"eq": "fluvial"},
            "defense": {"eq": "defended"}
        }
    },
    "pluvial": {
        "collections": ["fathom"],
        "query": {"flood_type": {"eq": "pluvial"}}
    }
}

# Register all at startup
for name, search in REGISTERED_SEARCHES.items():
    resp = requests.post(f"{TITILER_URL}/searches/register", json=search)
    SEARCH_IDS[name] = resp.json()["id"]
```

### API Endpoint: User Parameters

```python
@app.route("/api/fathom/tiles/{flood_type}/{z}/{x}/{y}")
def fathom_tiles(
    flood_type: str,
    z: int, x: int, y: int,
    return_period: int = 100,
    scenario: str = "historical",
    time_period: str = "baseline",
    defense: str = "undefended"
):
    # Get pre-registered search
    search_key = f"{flood_type}_{defense}"
    search_id = SEARCH_IDS[search_key]
    
    # Build runtime filter (CQL2-JSON)
    filter_cql = {
        "op": "and",
        "args": [
            {"op": "=", "args": [{"property": "return_period"}, return_period]},
            {"op": "=", "args": [{"property": "scenario"}, scenario]},
            {"op": "=", "args": [{"property": "time_period"}, time_period]}
        ]
    }
    
    # Proxy to TiTiler-pgSTAC
    tile_url = f"{TITILER_URL}/searches/{search_id}/tiles/{z}/{x}/{y}"
    params = {
        "filter": json.dumps(filter_cql),
        "assets": "depth",
        "rescale": "0,5",  # 0-5m depth
        "colormap_name": "blues"
    }
    
    resp = requests.get(tile_url, params=params)
    return Response(resp.content, mimetype="image/png")
```

### Frontend Usage

```javascript
// Clean, parameterized API
const fathomLayer = L.tileLayer(
  'https://api.gddatahub.org/fathom/tiles/fluvial/{z}/{x}/{y}?' +
  'return_period=100&scenario=rcp85&time_period=2050s&defense=undefended',
  { opacity: 0.7 }
).addTo(map);

// User changes dropdown → update params
document.getElementById('return-period').addEventListener('change', (e) => {
  const newUrl = updateUrlParam(fathomLayer._url, 'return_period', e.target.value);
  fathomLayer.setUrl(newUrl);
});
```

---

## Time-Series Animation Pattern

### Backend: Build Frame List

```python
@app.route("/api/datasets/{dataset_id}/timeseries")
def get_timeseries_frames(
    dataset_id: str,
    start_date: str,
    end_date: str
):
    # Register temporal search
    search_payload = {
        "collections": [dataset_id],
        "datetime": f"{start_date}/{end_date}",
        "sortby": [{"field": "datetime", "direction": "asc"}]
    }
    
    resp = requests.post(f"{TITILER_URL}/searches/register", json=search_payload)
    search_id = resp.json()["id"]
    
    # Get ordered item list
    items_resp = requests.get(f"{TITILER_URL}/searches/{search_id}/list")
    items = items_resp.json()["features"]
    
    # Build frame metadata
    frames = [
        {
            "datetime": item["properties"]["datetime"],
            "tile_url": f"/collections/{dataset_id}/items/{item['id']}/tiles/{{z}}/{{x}}/{{y}}?rescale=0,100&colormap_name=viridis"
        }
        for item in items
    ]
    
    return {"frames": frames}
```

### Frontend: Animate

```javascript
// Fetch frame list
const response = await fetch('/api/datasets/cmip6_temp/timeseries?start_date=2020-01-01&end_date=2050-12-31');
const data = await response.json();

// Cycle through frames
let currentFrame = 0;
let currentLayer;

function updateFrame() {
  const frame = data.frames[currentFrame];
  
  if (currentLayer) map.removeLayer(currentLayer);
  
  currentLayer = L.tileLayer(frame.tile_url, { opacity: 0.8 }).addTo(map);
  document.getElementById('timestamp').textContent = frame.datetime;
  
  currentFrame = (currentFrame + 1) % data.frames.length;
}

// Animate at 2fps
setInterval(updateFrame, 500);
```

### Critical: Fixed Color Scales

For consistent animation, **lock your color scale**:

```bash
# BAD: Auto-scaling (each frame different)
?colormap_name=viridis

# GOOD: Fixed range across all frames
?rescale=0,100&colormap_name=viridis
```

Otherwise January's "dark blue" might be 10°C while July's is 25°C.

---

## STAC Schema Requirements

### Temporal Properties

```json
{
  "type": "Feature",
  "stac_version": "1.0.0",
  "id": "fathom_fluvial_rp100_2050",
  "collection": "fathom",
  "properties": {
    "datetime": "2050-01-01T00:00:00Z",  // Required for temporal queries
    "flood_type": "fluvial",
    "defense": "undefended",
    "return_period": 100,
    "scenario": "rcp45",
    "time_period": "2050s"
  },
  "assets": {
    "depth": {
      "href": "s3://bucket/fathom_fluvial_rp100_2050.tif",
      "type": "image/tiff; application=geotiff; profile=cloud-optimized",
      "roles": ["data"]
    }
  }
}
```

### PostgreSQL Indexes

```sql
-- Temporal queries
CREATE INDEX idx_items_datetime ON items USING BTREE (datetime);
CREATE INDEX idx_items_collection_datetime ON items (collection_id, datetime);

-- Custom property filters
CREATE INDEX idx_items_flood_type ON items ((properties->>'flood_type'));
CREATE INDEX idx_items_return_period ON items (((properties->>'return_period')::int));
CREATE INDEX idx_items_scenario ON items ((properties->>'scenario'));
CREATE INDEX idx_items_time_period ON items ((properties->>'time_period'));
```

---

## Decision Matrix: When to Use What

| Use Case | Pattern | Why |
|----------|---------|-----|
| **Common filter combinations** | Registered searches | Performance, clean URLs, caching |
| **User-specific parameters** | Query params at tile time | Flexibility, don't explode search registry |
| **Time-series animation** | Registered search + item list | Get ordered frames to cycle through |
| **Latest composite** | Registered search + mosaic tiles | Single tile showing latest/best pixels |
| **Ad-hoc exploration** | Dynamic `/mosaic` endpoint | No need to pre-register |
| **Multi-dimensional catalogs** | Register categories, filter via params | Balance of performance + flexibility |

---

## Complete Example: DDHGeo FATHOM Integration

### 1. Register Searches at Deployment

```python
# startup.py
def register_fathom_searches():
    flood_types = ["fluvial", "pluvial", "coastal"]
    defenses = ["defended", "undefended"]
    
    search_ids = {}
    
    for flood_type in flood_types:
        for defense in defenses:
            if flood_type == "pluvial" and defense == "defended":
                continue  # Pluvial doesn't have defended variant
            
            search = {
                "collections": ["fathom"],
                "query": {
                    "flood_type": {"eq": flood_type},
                    "defense": {"eq": defense}
                }
            }
            
            resp = requests.post(
                f"{TITILER_PGSTAC_URL}/searches/register",
                json=search
            )
            
            key = f"{flood_type}_{defense}"
            search_ids[key] = resp.json()["id"]
            
    return search_ids

FATHOM_SEARCHES = register_fathom_searches()
```

### 2. Gateway API

```python
# api/fathom.py
@app.route("/fathom/<flood_type>/tiles/<int:z>/<int:x>/<int:y>")
def get_fathom_tile(flood_type: str, z: int, x: int, y: int):
    # Query params
    return_period = request.args.get("return_period", 100, type=int)
    scenario = request.args.get("scenario", "historical")
    time_period = request.args.get("time_period", "baseline")
    defense = request.args.get("defense", "undefended")
    
    # Get registered search
    search_key = f"{flood_type}_{defense}"
    if search_key not in FATHOM_SEARCHES:
        return {"error": "Invalid flood type/defense combination"}, 400
    
    search_id = FATHOM_SEARCHES[search_key]
    
    # Build filter
    filter_cql = {
        "op": "and",
        "args": [
            {"op": "=", "args": [{"property": "return_period"}, return_period]},
            {"op": "=", "args": [{"property": "scenario"}, scenario]},
            {"op": "=", "args": [{"property": "time_period"}, time_period]}
        ]
    }
    
    # Visualization params
    viz_params = {
        "assets": "depth",
        "rescale": "0,5",
        "colormap_name": "blues",
        "resampling_method": "bilinear"
    }
    
    # Request tile
    tile_url = f"{TITILER_PGSTAC_URL}/searches/{search_id}/tiles/{z}/{x}/{y}"
    params = {
        "filter": json.dumps(filter_cql),
        **viz_params
    }
    
    resp = requests.get(tile_url, params=params)
    
    return Response(
        resp.content,
        mimetype="image/png",
        headers={"Cache-Control": "public, max-age=86400"}
    )
```

### 3. Frontend Widget

```javascript
// fathom-viewer.js
class FathomViewer {
  constructor(map) {
    this.map = map;
    this.layer = null;
    this.config = {
      floodType: 'fluvial',
      returnPeriod: 100,
      scenario: 'historical',
      timePeriod: 'baseline',
      defense: 'undefended'
    };
  }
  
  updateLayer() {
    const url = `https://api.gddatahub.org/fathom/${this.config.floodType}/tiles/{z}/{x}/{y}?` +
      `return_period=${this.config.returnPeriod}&` +
      `scenario=${this.config.scenario}&` +
      `time_period=${this.config.timePeriod}&` +
      `defense=${this.config.defense}`;
    
    if (this.layer) {
      this.layer.setUrl(url);
    } else {
      this.layer = L.tileLayer(url, {
        opacity: 0.7,
        attribution: 'FATHOM'
      }).addTo(this.map);
    }
  }
  
  setFloodType(type) {
    this.config.floodType = type;
    this.updateLayer();
  }
  
  setReturnPeriod(period) {
    this.config.returnPeriod = period;
    this.updateLayer();
  }
  
  setScenario(scenario) {
    this.config.scenario = scenario;
    this.updateLayer();
  }
}

// Usage
const viewer = new FathomViewer(map);
document.getElementById('flood-type').addEventListener('change', (e) => {
  viewer.setFloodType(e.target.value);
});
```

---

## Key Takeaways

1. **Registered searches = smart filters** - Pre-register common query patterns, get cacheable IDs
2. **Query params locked at registration** - Collections, datetime, bbox, base filters
3. **Viz params flexible at tile time** - Colormap, rescale, assets, resampling
4. **Runtime filtering via `filter` param** - Combine registered search with user-specific filters
5. **Animation pattern** - Register search → get item list → tile individual items
6. **Index your STAC properties** - Especially datetime and custom query fields
7. **Fixed color scales for animation** - Always specify `rescale` for consistent visualization
8. **Small search registry** - 5-10 registered searches + dynamic params >> thousands of registered searches

This pattern gives you **performance** (caching), **flexibility** (user parameters), and **clean APIs** (no complex JSON in URLs).
```