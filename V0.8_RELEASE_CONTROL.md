# V0.8 Release Control - Asset Versioning & Lineage

**Created**: 30 JAN 2026
**Status**: PHASE A & B COMPLETE
**Purpose**: Enable version-aware service URLs (`/latest`, `/v1`) via asset lineage tracking
**Driver**: Service Layer (TiTiler, TiPG, STAC API) needs to resolve "latest" version of datasets

## Implementation Progress (30 JAN 2026)

### Phase A: Schema Foundation (COMPLETE)
| Tier | Status | Files Modified |
|------|--------|----------------|
| TIER 1: Platform Registry | ✅ | `platform_registry.py`, `sql_generator.py` |
| TIER 2: GeospatialAsset | ✅ | `asset.py`, `asset_repository.py`, `sql_generator.py` |
| TIER 3: JobRecord | ✅ | `job.py`, `sql_generator.py` |
| TIER 4: ApiRequest | ✅ | `platform.py`, `sql_generator.py` |

### Phase B: Business Logic (COMPLETE)
| Tier | Status | Files Modified |
|------|--------|----------------|
| TIER 5: Asset Service | ✅ | `asset_service.py` |
| TIER 6: Validate Endpoint | ⏳ Ready | Service methods ready, endpoint TBD |
| TIER 7: Submit Enhancement | ⏳ Ready | Service methods ready, endpoint TBD |

### Next Steps
1. **Deploy & Rebuild**: Run `action=rebuild` to create new schema
2. **TIER 6**: Create `/api/platform/validate` endpoint
3. **TIER 7**: Enhance `/api/platform/submit` with version params
4. **TIER 8**: STAC Collection ID generation
5. **TIER 9**: Service Layer integration (geotiler repo)

---

## Executive Summary

Enable B2B platforms to submit versioned assets with explicit lineage relationships. The system will track which assets belong to the same "lineage" (same nominal identity, different versions) and support resolution of "latest" version for service URLs.

**Key Principle**: B2B app controls version ordinality. We store and query - we don't interpret version strings.

---

## Use Case

```
DDH submits:
  v1: {dataset_id: "floods", resource_id: "jakarta", version_id: "v1.0"}
  v2: {dataset_id: "floods", resource_id: "jakarta", version_id: "v2.0", previous_version: "v1.0"}
  v3: {dataset_id: "floods", resource_id: "jakarta", version_id: "v3.0", previous_version: "v2.0"}

Service Layer URLs:
  /tiles/floods/jakarta/latest  → resolves to v3.0 COG
  /tiles/floods/jakarta/v1.0    → resolves to v1.0 COG
  /tiles/floods/jakarta/v2.0    → resolves to v2.0 COG
```

---

## Data Model

### 1. Platform Registry Enhancement

**Table**: `app.platforms`

```sql
-- Existing columns
platform_id VARCHAR(50) PRIMARY KEY,
display_name VARCHAR(100),
required_refs JSONB,        -- ["dataset_id", "resource_id", "version_id"]
optional_refs JSONB,

-- NEW columns for versioning
nominal_refs JSONB,         -- ["dataset_id", "resource_id"] - identity WITHOUT version
version_ref VARCHAR(50),    -- "version_id" - the field that holds version (NULL = no versioning)
uses_versioning BOOLEAN DEFAULT FALSE
```

**DDH Platform Configuration**:
```json
{
  "platform_id": "ddh",
  "required_refs": ["dataset_id", "resource_id", "version_id"],
  "nominal_refs": ["dataset_id", "resource_id"],
  "version_ref": "version_id",
  "uses_versioning": true
}
```

### 2. GeospatialAsset Enhancement

**Table**: `app.geospatial_assets`

```sql
-- Existing columns
asset_id VARCHAR(64) PRIMARY KEY,      -- hash(platform_id + ALL refs)
platform_id VARCHAR(50),
platform_refs JSONB,                    -- {"dataset_id": "X", "resource_id": "Y", "version_id": "v1"}

-- NEW columns for lineage
lineage_id VARCHAR(64),                 -- hash(platform_id + NOMINAL refs only)
version_ordinal INTEGER,                -- B2B-provided ordering (1, 2, 3...)
previous_asset_id VARCHAR(64),          -- Explicit link to previous version
is_latest BOOLEAN DEFAULT TRUE,         -- Denormalized flag for fast queries

-- NEW indexes
CREATE INDEX idx_assets_lineage ON geospatial_assets(lineage_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_assets_latest ON geospatial_assets(lineage_id, is_latest) WHERE deleted_at IS NULL AND is_latest = TRUE;
```

### 3. Lineage ID Generation

```python
def generate_lineage_id(platform_id: str, platform_refs: Dict, nominal_refs: List[str]) -> str:
    """
    Generate lineage ID from nominal refs only.

    Example:
        platform_id = "ddh"
        platform_refs = {"dataset_id": "floods", "resource_id": "jakarta", "version_id": "v2"}
        nominal_refs = ["dataset_id", "resource_id"]

        → lineage_id = hash("ddh|dataset_id:floods|resource_id:jakarta")
    """
    # Extract only nominal values
    nominal_values = {k: platform_refs[k] for k in sorted(nominal_refs) if k in platform_refs}
    sorted_refs = json.dumps(nominal_values, sort_keys=True, separators=(',', ':'))
    composite = f"{platform_id}|{sorted_refs}"
    return hashlib.sha256(composite.encode()).hexdigest()[:32]
```

### 4. Asset-Centric Entity Model

**Principle**: Everything maps back to GeospatialAsset. Platform ownership flows through the asset.

```
┌──────────────────────────────────────────────────────────────────────┐
│                        app.platforms                                  │
│                     (platform_id: "ddh")                              │
│                                                                       │
│  Defines: required_refs, optional_refs, nominal_refs, version_ref    │
└──────────────────────────────────────────────────────────────────────┘
                                │
                                │ FK: platform_id
                                ▼
┌──────────────────────────────────────────────────────────────────────┐
│                     app.geospatial_assets                             │
│                    (FIRST-CLASS ENTITY)                               │
│                                                                       │
│  asset_id (PK)                                                        │
│  platform_id ─────────────────────────────────────────┐ FK to platforms│
│  platform_refs: {"dataset_id": "X", ...}              │               │
│  lineage_id                                           │               │
│  is_latest, is_served                                 │               │
└───────────────────────────────────────────────────────│───────────────┘
          │                              │              │
          │ FK: asset_id                 │              │
          ▼                              ▼              │
┌─────────────────────────┐  ┌─────────────────────────┐│
│      app.jobs           │  │   app.api_requests      ││
│                         │  │                         ││
│  job_id (PK)            │  │  request_id (PK)        ││
│  asset_id (NEW) ────────┼──│  asset_id (NEW) ────────┼┘
│  platform_id (NEW) ─────┼──│  platform_id (NEW) ─────┘
│                         │  │                         │
└─────────────────────────┘  └─────────────────────────┘
          │
          │ item references job via properties
          ▼
┌─────────────────────────┐
│     pgstac.items        │
│                         │
│  platform:client: "ddh" │  (STAC property, matches platform_id)
│  app:asset_id           │  (NEW - link back to asset)
└─────────────────────────┘
```

### 5. JobRecord Enhancement

**Table**: `app.jobs`

```sql
-- NEW columns for asset linkage
asset_id VARCHAR(64) REFERENCES app.geospatial_assets(asset_id),
platform_id VARCHAR(50) REFERENCES app.platforms(platform_id),

-- NEW indexes
CREATE INDEX idx_jobs_asset ON jobs(asset_id) WHERE asset_id IS NOT NULL;
CREATE INDEX idx_jobs_platform ON jobs(platform_id) WHERE platform_id IS NOT NULL;
```

**Rationale**:
- `asset_id`: Canonical link to the asset this job processes
- `platform_id`: Denormalized for fast "all jobs for platform X" queries

**Note**: Not all jobs have assets (e.g., `hello_world`, maintenance jobs). Columns are nullable.

### 6. ApiRequest Enhancement

**Table**: `app.api_requests`

```sql
-- NEW columns for asset linkage
asset_id VARCHAR(64) REFERENCES app.geospatial_assets(asset_id),
platform_id VARCHAR(50) REFERENCES app.platforms(platform_id),

-- EXISTING DDH columns remain for backward compatibility
-- (dataset_id, resource_id, version_id) - these become queryable via platform_refs on asset

-- NEW index
CREATE INDEX idx_api_requests_asset ON api_requests(asset_id) WHERE asset_id IS NOT NULL;
CREATE INDEX idx_api_requests_platform ON api_requests(platform_id);
```

**Rationale**:
- `asset_id`: Links request to the asset it created/updated
- `platform_id`: Identifies which B2B app made the request
- Keep existing DDH columns for API contract compatibility (request tracking)

### 7. STAC Item Properties

STAC items include asset linkage in properties:

```json
{
  "properties": {
    "platform:client": "ddh",
    "app:asset_id": "abc123...",
    "app:lineage_id": "def456...",
    "lineage:dataset_id": "floods",
    "lineage:resource_id": "jakarta"
  }
}
```

**Query Pattern** (Service Layer):
```sql
-- Get STAC items for a platform
SELECT * FROM pgstac.items
WHERE content->'properties'->>'platform:client' = 'ddh';

-- Get STAC item for an asset
SELECT * FROM pgstac.items
WHERE content->'properties'->>'app:asset_id' = ?;
```

### 8. Query Patterns

**All entities for a platform**:
```sql
-- Jobs for DDH
SELECT * FROM jobs WHERE platform_id = 'ddh';

-- Assets for DDH
SELECT * FROM geospatial_assets WHERE platform_id = 'ddh';

-- API Requests for DDH
SELECT * FROM api_requests WHERE platform_id = 'ddh';
```

**Full lineage via asset**:
```sql
-- Get everything related to an asset
SELECT
    a.*,
    j.job_id, j.status as job_status,
    r.request_id, r.created_at as request_time
FROM geospatial_assets a
LEFT JOIN jobs j ON j.asset_id = a.asset_id
LEFT JOIN api_requests r ON r.asset_id = a.asset_id
WHERE a.asset_id = ?;
```

**Platform-specific ref queries** (using GIN index):
```sql
-- Find DDH asset by dataset_id + resource_id
SELECT * FROM geospatial_assets
WHERE platform_id = 'ddh'
  AND platform_refs @> '{"dataset_id": "floods", "resource_id": "jakarta"}';
```

---

## Architecture: ETL vs Service Layer

### Separation of Concerns

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              ETL LAYER                                       │
│                    (Function App + Docker Worker)                            │
│                                                                              │
│  RESPONSIBILITIES:                                                           │
│  ✅ Receive submit/validate requests from B2B                                │
│  ✅ Generate lineage_id from nominal refs                                    │
│  ✅ Set version_ordinal, previous_asset_id                                   │
│  ✅ Manage is_latest flag (flip on new version)                              │
│  ✅ Write COGs/vectors to storage                                            │
│  ✅ Create STAC items with lineage metadata                                  │
│  ✅ Populate geospatial_assets table                                         │
│                                                                              │
│  DOES NOT:                                                                   │
│  ❌ Serve tiles or features                                                  │
│  ❌ Route /latest URLs                                                       │
│  ❌ Communicate directly with Service Layer                                  │
└──────────────────────────────────┬──────────────────────────────────────────┘
                                   │
                                   ▼
                    ┌──────────────────────────┐
                    │     DATABASE (Contract)   │
                    │                          │
                    │  app.geospatial_assets   │
                    │  - lineage_id            │
                    │  - is_latest             │
                    │  - version_ordinal       │
                    │  - blob_path             │
                    │  - stac_item_id          │
                    │                          │
                    │  pgstac.items            │
                    │  - STAC metadata         │
                    └──────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           SERVICE LAYER                                      │
│                    (geotiler: TiTiler + TiPG + STAC API)                     │
│                                                                              │
│  RESPONSIBILITIES:                                                           │
│  ✅ Query geospatial_assets by lineage_id                                    │
│  ✅ Resolve /latest → WHERE is_latest = TRUE                                 │
│  ✅ Resolve /v1.0 → WHERE platform_refs->>'version_id' = 'v1.0'              │
│  ✅ Enforce access control (approval_state, clearance_state)                 │
│  ✅ Generate tile/feature URLs from blob_path                                │
│  ✅ Serve tiles via TiTiler, features via TiPG                               │
│                                                                              │
│  DOES NOT:                                                                   │
│  ❌ Write to geospatial_assets                                               │
│  ❌ Process/transform data                                                   │
│  ❌ Communicate directly with ETL Layer                                      │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Key Principle**: The database is the contract. ETL writes, Service Layer reads. No direct communication.

---

## STAC Collection ID Strategy

### Decision: Lineage ID = STAC Collection ID

The `lineage_id` (derived from `dataset_id` + `resource_id`) maps directly to the STAC Collection ID. This creates a clean alignment between our data model and OGC/STAC standards.

```
DDH Identifiers          Our Data Model         STAC
───────────────          ───────────────        ────
dataset_id + resource_id  →  Lineage      →     Collection
version_id                →  GeospatialAsset →  Item (within collection)
```

### Collection ID Format

**Format**: `{dataset_id}--{resource_id}`

```
DDH Input:
  dataset_id: "flood-data"
  resource_id: "region-north"
  version_id: "v2"

STAC Mapping:
  Collection ID: "flood-data--region-north"
  Item ID: "flood-data--region-north--v2" (or hash-based)
```

**Rationale for double-dash separator**:
- Single dash `-` common in identifiers themselves
- Double-dash `--` unlikely in source IDs, easy to parse
- URL-safe, no encoding needed

### OGC-Compliant URLs

This mapping enables DDH identifiers to flow naturally into OGC/STAC URLs:

| Concept | URL Pattern | Resolution |
|---------|-------------|------------|
| All versions | `/collections/flood-data--region-north/items` | All items in lineage |
| Latest version | `/collections/flood-data--region-north/items?is_latest=true` | `WHERE is_latest = TRUE` |
| Specific version | `/collections/flood-data--region-north/items?version=v2` | `WHERE version_id = 'v2'` |
| Tiles (latest) | `/collections/flood-data--region-north/tiles/{z}/{x}/{y}` | Resolve latest, serve COG |

### DDH OpenAPI Alignment

The DDH B2B read API uses OData-style conventions. Our geospatial read services (TiTiler, TiPG, STAC API) follow OGC standards. Key alignment decisions:

| Aspect | DDH OpenAPI | Our Approach | Notes |
|--------|-------------|--------------|-------|
| Identifiers | `dataset_unique_id`, `resource_unique_id` | Use as Collection ID | Direct mapping |
| Pagination | `skip`/`top` | Accept as aliases for `offset`/`limit` | Service Layer config |
| Versioning | `?version=` param | Same pattern | Filter items by version |
| Response format | Custom JSON | GeoJSON/STAC JSON | OGC standard (no conversion) |
| Filtering | SQL-like | CQL / bbox / datetime | OGC standard (no conversion) |

**Principle**: OGC standards take priority. DDH identifiers flow through; DDH query conventions are accommodated where trivial (pagination aliases, version param).

### Implementation Location

| Responsibility | rmhgeoapi (ETL) | Geotiler App (Service) |
|----------------|-----------------|------------------------|
| Generate Collection ID from lineage | ✅ On STAC collection creation | - |
| Store `dataset_id`, `resource_id` in collection metadata | ✅ For reverse lookup | - |
| Create items with `version` property | ✅ On asset ingest | - |
| Query by Collection ID | - | ✅ Standard STAC/OGC |
| Filter items by `?version=` | - | ✅ Property filter |
| Accept `skip`/`top` pagination | - | ✅ Alias in config |

### STAC Item Properties

Each STAC item includes lineage metadata:

```json
{
  "type": "Feature",
  "stac_version": "1.0.0",
  "id": "flood-data--region-north--v2",
  "collection": "flood-data--region-north",
  "properties": {
    "datetime": "2026-01-30T00:00:00Z",
    "version": "v2",
    "version_ordinal": 2,
    "is_latest": true,
    "lineage:dataset_id": "flood-data",
    "lineage:resource_id": "region-north",
    "lineage:previous_version": "v1"
  },
  "links": [
    {
      "rel": "predecessor-version",
      "href": "./flood-data--region-north--v1",
      "type": "application/geo+json"
    }
  ],
  "assets": {
    "data": {
      "href": "https://storage.../flood-data/region-north/v2.tif",
      "type": "image/tiff; application=geotiff; profile=cloud-optimized"
    }
  }
}
```

---

## API Design: Validate-Then-Submit Pattern

### Why Two Endpoints?

B2B apps need to know the current state before submitting a new version:
- Does this lineage exist?
- What's the current latest version?
- What version_ordinal should I use?

**Pattern**: `validate/` is read-only reconnaissance, `submit/` is the write operation.

### Endpoint 1: Platform Validate (NEW)

**Endpoint**: `POST /api/platform/validate`

**Purpose**: Check lineage state before submit. Read-only, no side effects.

**Request**:
```json
{
  "dataset_id": "floods",
  "resource_id": "jakarta",
  "version_id": "v3.0"           // The version B2B WANTS to submit
}
```

**Response - New Lineage** (no existing assets):
```json
{
  "lineage_exists": false,
  "lineage_id": "abc123...",
  "suggested_action": "submit_new",
  "suggested_params": {
    "version_ordinal": 1,
    "previous_version_id": null
  }
}
```

**Response - Existing Lineage** (versions exist):
```json
{
  "lineage_exists": true,
  "lineage_id": "abc123...",
  "current_latest": {
    "version_id": "v2.0",
    "version_ordinal": 2,
    "asset_id": "bbb...",
    "is_served": true,           // Has active service URL
    "created_at": "2026-01-15T..."
  },
  "version_history": [
    {"version_id": "v2.0", "ordinal": 2, "is_latest": true, "is_served": true},
    {"version_id": "v1.0", "ordinal": 1, "is_latest": false, "is_served": false}
  ],
  "suggested_action": "submit_new_version",
  "suggested_params": {
    "version_ordinal": 3,
    "previous_version_id": "v2.0"
  },
  "warnings": []
}
```

**Response - Version Already Exists**:
```json
{
  "lineage_exists": true,
  "lineage_id": "abc123...",
  "version_exists": true,
  "existing_asset": {
    "version_id": "v3.0",
    "asset_id": "ccc...",
    "status": "completed"
  },
  "suggested_action": "use_overwrite_or_change_version",
  "warnings": ["Version v3.0 already exists. Use overwrite=true to replace."]
}
```

### Endpoint 2: Platform Submit (Enhanced)

**Endpoint**: `POST /api/platform/submit`

**Request** (with versioning):
```json
{
  "dataset_id": "floods",
  "resource_id": "jakarta",
  "version_id": "v3.0",
  "data_type": "raster",
  "blob_name": "path/to/file.tif",

  // Version control (from validate response)
  "version_ordinal": 3,
  "previous_version_id": "v2.0",

  // Service control (NEW)
  "serve_previous_versions": true,    // Keep v1, v2 accessible via /v1, /v2 URLs
  "retire_versions": ["v1.0"]         // Optional: stop serving specific old versions
}
```

**Submit Logic**:
```python
def handle_submit(request):
    platform = get_platform("ddh")

    # Generate lineage_id
    lineage_id = generate_lineage_id(platform, request.platform_refs)

    # Validate against current state
    current_latest = get_latest_in_lineage(lineage_id)
    if current_latest:
        # Verify ordinal is correct (should be current + 1)
        if request.version_ordinal != current_latest.version_ordinal + 1:
            raise ValidationError(
                f"version_ordinal should be {current_latest.version_ordinal + 1}, "
                f"got {request.version_ordinal}. Use /validate to get current state."
            )

        # Verify previous_version_id matches current latest
        if request.previous_version_id:
            expected_prev = current_latest.platform_refs.get('version_id')
            if request.previous_version_id != expected_prev:
                raise ValidationError(
                    f"previous_version_id should be '{expected_prev}', "
                    f"got '{request.previous_version_id}'."
                )

        # Flip is_latest on current
        current_latest.is_latest = False
        current_latest.save()

    # Handle version retirement
    if request.retire_versions:
        for version_id in request.retire_versions:
            asset = get_asset_by_version(lineage_id, version_id)
            if asset:
                asset.is_served = False  # Service layer won't serve this
                asset.save()

    # Create new asset
    asset = create_asset(
        lineage_id=lineage_id,
        version_ordinal=request.version_ordinal,
        previous_asset_id=current_latest.asset_id if current_latest else None,
        is_latest=True,
        is_served=True,
        ...
    )
```

---

## Workflow: Single Submit vs Separate Endpoints

**Decision**: Single `submit/` endpoint with smart validation, supported by `validate/` for reconnaissance.

| Approach | Pros | Cons |
|----------|------|------|
| Separate `/submit-new` and `/submit-version` | Clear intent | More endpoints to maintain |
| Single `/submit` with params | Simpler API, one code path | Need good validation |
| **`/validate` + `/submit`** (CHOSEN) | B2B can check state first, submit knows context | Two calls (but validate is optional) |

**Rationale**:
- `validate/` is optional but recommended - helps B2B apps avoid errors
- `submit/` handles both new lineages and new versions
- Validation in submit catches mistakes if B2B skips validate
- Version control params (`version_ordinal`, `previous_version_id`) make intent explicit

---

## Service Control: Serving Previous Versions

### New Column: `is_served`

```sql
ALTER TABLE geospatial_assets ADD COLUMN is_served BOOLEAN DEFAULT TRUE;
```

**Semantics**:
- `is_served = TRUE`: Service Layer will serve this version at `/v1.0` URL
- `is_served = FALSE`: Version exists but is not accessible via service URLs
- `is_latest = TRUE`: Service Layer serves this at `/latest` URL

**Use Cases**:

| Scenario | is_latest | is_served | Result |
|----------|-----------|-----------|--------|
| Current version | TRUE | TRUE | Served at `/latest` and `/v3` |
| Previous version, still accessible | FALSE | TRUE | Served at `/v2` only |
| Retired version | FALSE | FALSE | Not served, but data preserved |
| Soft-deleted | FALSE | FALSE | Not served, marked deleted |

### Service Layer Query Updates

```sql
-- Resolve /latest (unchanged)
SELECT * FROM geospatial_assets
WHERE lineage_id = ? AND is_latest = TRUE AND deleted_at IS NULL;

-- Resolve /v2.0 (now checks is_served)
SELECT * FROM geospatial_assets
WHERE lineage_id = ?
  AND platform_refs->>'version_id' = 'v2.0'
  AND is_served = TRUE
  AND deleted_at IS NULL;

-- List available versions (for /versions endpoint)
SELECT platform_refs->>'version_id' as version, is_latest
FROM geospatial_assets
WHERE lineage_id = ? AND is_served = TRUE AND deleted_at IS NULL
ORDER BY version_ordinal DESC;
```

---

## Service Layer Integration

### Latest Resolution Query

```python
def get_latest_asset(lineage_id: str) -> GeospatialAsset:
    """Get the latest version of an asset lineage."""
    return db.query(GeospatialAsset).filter(
        GeospatialAsset.lineage_id == lineage_id,
        GeospatialAsset.is_latest == True,
        GeospatialAsset.deleted_at == None
    ).first()

def get_asset_by_version(lineage_id: str, version_id: str) -> GeospatialAsset:
    """Get specific version of an asset."""
    return db.query(GeospatialAsset).filter(
        GeospatialAsset.lineage_id == lineage_id,
        GeospatialAsset.platform_refs['version_id'].astext == version_id,
        GeospatialAsset.deleted_at == None
    ).first()

def get_version_history(lineage_id: str) -> List[GeospatialAsset]:
    """Get all versions ordered by ordinal."""
    return db.query(GeospatialAsset).filter(
        GeospatialAsset.lineage_id == lineage_id,
        GeospatialAsset.deleted_at == None
    ).order_by(GeospatialAsset.version_ordinal.desc()).all()
```

### URL Routing (Future - Service Layer)

```
/tiles/{dataset}/{resource}/latest    → get_latest_asset(lineage_id)
/tiles/{dataset}/{resource}/v1.0      → get_asset_by_version(lineage_id, "v1.0")
/tiles/{dataset}/{resource}/versions  → get_version_history(lineage_id)
```

---

## Implementation Tiers

### TIER 1: Platform Registry Enhancement (ETL) ✅ COMPLETE (30 JAN 2026)
- [x] Add `nominal_refs`, `version_ref`, `uses_versioning` to Platform model
- [x] Update DDH seed data with versioning config
- [x] Update sql_generator.py for new columns
- [x] Update platform_registry_repository.py (no changes needed - uses model-driven DDL)

### TIER 2: GeospatialAsset Enhancement (ETL) ✅ COMPLETE (30 JAN 2026)
- [x] Add `lineage_id` column (VARCHAR 64)
- [x] Add `version_ordinal` column (INTEGER)
- [x] Add `previous_asset_id` column (VARCHAR 64, FK to self)
- [x] Add `is_latest` column (BOOLEAN, default TRUE)
- [x] Add `is_served` column (BOOLEAN, default TRUE)
- [x] Add `generate_lineage_id()` function to asset model
- [x] Update sql_generator.py for new columns and indexes (upsert function)
- [x] Update asset_repository.py for new fields (_row_to_model, upsert, lineage queries)

### TIER 3: JobRecord Enhancement (ETL) ✅ COMPLETE (30 JAN 2026)
- [x] Add `asset_id` column (VARCHAR 64, FK to geospatial_assets, nullable)
- [x] Add `platform_id` column (VARCHAR 50, FK to platforms, nullable)
- [x] Add indexes: `idx_jobs_asset`, `idx_jobs_platform`
- [x] Update JobRecord model in `core/models/job.py`
- [x] Update sql_generator.py for new columns
- [ ] Update job_repository.py to populate asset_id/platform_id on creation (TIER 7)
- [ ] Update job submission to link asset when available (TIER 7)

### TIER 4: ApiRequest Enhancement (ETL) ✅ COMPLETE (30 JAN 2026)
- [x] Add `asset_id` column (VARCHAR 64, FK to geospatial_assets, nullable)
- [x] Add `platform_id` column (VARCHAR 50, FK to platforms)
- [x] Add indexes: `idx_api_requests_asset`, `idx_api_requests_platform`
- [x] Update ApiRequest model in `core/models/platform.py`
- [x] Update sql_generator.py for new columns
- [ ] Update platform submit to populate asset_id/platform_id (TIER 7)

### TIER 5: Asset Service Enhancement (ETL) ✅ COMPLETE (30 JAN 2026)
- [x] Update `create_or_update_asset()` to handle versioning
- [x] Add `get_latest_in_lineage(lineage_id)` method
- [x] Add `get_by_version(lineage_id, version_id)` method (via `get_asset_by_version`)
- [x] Add `get_version_history(lineage_id)` method
- [x] Add `get_lineage_state(platform_refs)` method (for validate)
- [x] Handle `is_latest` flag flip on new version submit
- [x] Handle `is_served` updates for version retirement

### TIER 6: Platform Validate Endpoint (ETL) - READY TO IMPLEMENT
- [ ] Create `POST /api/platform/validate` endpoint
- [ ] Return lineage state: exists, current_latest, version_history
- [ ] Return suggested_params for submit
- [ ] Check if requested version already exists

### TIER 7: Platform Submit Enhancement (ETL) - READY TO IMPLEMENT
- [ ] Add `version_ordinal` parameter
- [ ] Add `previous_version_id` parameter
- [ ] Add `serve_previous_versions` parameter
- [ ] Add `retire_versions` parameter
- [ ] Validate ordinal matches expected (current + 1)
- [ ] Validate previous_version_id matches current latest
- [ ] Update PlatformSubmitRequest model
- [ ] Populate `asset_id` and `platform_id` on Job and ApiRequest

### TIER 8: STAC Collection ID Generation (ETL)
- [ ] Generate Collection ID as `{dataset_id}--{resource_id}` on submit
- [ ] Create STAC collection if not exists (on first version)
- [ ] Add `lineage:dataset_id`, `lineage:resource_id` to item properties
- [ ] Add `version`, `version_ordinal`, `is_latest` to item properties
- [ ] Add `predecessor-version` link to previous item
- [ ] Add `app:asset_id` to item properties (link back)
- [ ] Store Collection ID in `geospatial_assets.stac_collection_id`

### TIER 9: Service Layer Integration (geotiler repo - FUTURE)
- [ ] Add `/latest` resolution query
- [ ] Add version-specific routing (`/v1.0`)
- [ ] Add `/versions` list endpoint
- [ ] Respect `is_served` flag in queries
- [ ] Accept `skip`/`top` as pagination aliases
- [ ] Update TiTiler/TiPG URL generation

---

## Migration Strategy

1. **Schema Changes**: Add new columns with defaults (non-breaking)
   - `lineage_id`: Default to `asset_id` for existing assets
   - `version_ordinal`: Default to 1
   - `is_latest`: Default to TRUE
   - `previous_asset_id`: Default to NULL

2. **Backfill**: For existing DDH assets, compute `lineage_id` from nominal refs

3. **Deploy**: Roll out with backward compatibility - old submits work, new versioning optional

---

## Example Lineage Chain

```
Lineage: hash("ddh|dataset_id:floods|resource_id:jakarta") = "abc123..."

┌─────────────────────────────────────────────────────────────────────┐
│ asset_id    │ lineage_id │ version_ordinal │ previous_asset_id │ is_latest │
├─────────────────────────────────────────────────────────────────────┤
│ aaa...      │ abc123     │ 1               │ NULL              │ FALSE     │
│ bbb...      │ abc123     │ 2               │ aaa...            │ FALSE     │
│ ccc...      │ abc123     │ 3               │ bbb...            │ TRUE      │
└─────────────────────────────────────────────────────────────────────┘

Query: SELECT * FROM assets WHERE lineage_id = 'abc123' AND is_latest = TRUE
Result: ccc... (v3)
```

---

## Open Questions

### Resolved

1. **Version Retirement**: ✅ RESOLVED
   - Use `is_served = FALSE` to stop serving without deleting
   - Data preserved, just not accessible via service URLs
   - Can be re-enabled by setting `is_served = TRUE`

2. **Separate Workflow vs Parameterized**: ✅ RESOLVED
   - Single `submit/` endpoint handles both new lineages and new versions
   - `validate/` endpoint provides reconnaissance before submit
   - Version params make intent explicit

### Open

3. **Latest Promotion**: If latest is deleted/unpublished, should we auto-promote previous version to `is_latest`?
   - Option A: Auto-promote (convenient but implicit)
   - Option B: Require explicit action (safer but more work for B2B)
   - Option C: Leave no latest until B2B submits again

4. **STAC Lineage**: ✅ RESOLVED - See "STAC Collection ID Strategy" section above
   - Collection ID = `{dataset_id}--{resource_id}` (lineage identifier)
   - Items include `lineage:` prefixed properties for DDH identifiers
   - Items link to predecessors with `rel: predecessor-version`
   - OGC standards take priority over DDH conventions

5. **Validate Authentication**: Should `/validate` require same auth as `/submit`?
   - It exposes lineage existence (information disclosure)
   - Probably yes - same auth level

6. **Concurrent Submits**: What if two B2B processes both validate, then both submit?
   - First submit succeeds, second fails ordinal validation
   - Advisory locks already in place for asset creation
   - Should be safe, but need to test

---

## B2B Workflow Example

### First Version (New Lineage)

```bash
# Step 1: Validate (optional but recommended)
POST /api/platform/validate
{
  "dataset_id": "floods",
  "resource_id": "jakarta",
  "version_id": "v1.0"
}
# Response: {"lineage_exists": false, "suggested_params": {"version_ordinal": 1}}

# Step 2: Submit
POST /api/platform/submit
{
  "dataset_id": "floods",
  "resource_id": "jakarta",
  "version_id": "v1.0",
  "version_ordinal": 1,
  "data_type": "raster",
  "blob_name": "floods/jakarta/v1.tif"
}
# Response: {"job_id": "...", "asset_id": "aaa..."}
```

### Second Version (Add to Lineage)

```bash
# Step 1: Validate
POST /api/platform/validate
{
  "dataset_id": "floods",
  "resource_id": "jakarta",
  "version_id": "v2.0"
}
# Response: {
#   "lineage_exists": true,
#   "current_latest": {"version_id": "v1.0", "version_ordinal": 1},
#   "suggested_params": {"version_ordinal": 2, "previous_version_id": "v1.0"}
# }

# Step 2: Submit with version params
POST /api/platform/submit
{
  "dataset_id": "floods",
  "resource_id": "jakarta",
  "version_id": "v2.0",
  "version_ordinal": 2,
  "previous_version_id": "v1.0",
  "serve_previous_versions": true,   # Keep v1 accessible
  "data_type": "raster",
  "blob_name": "floods/jakarta/v2.tif"
}
```

### Retire Old Version

```bash
POST /api/platform/submit
{
  "dataset_id": "floods",
  "resource_id": "jakarta",
  "version_id": "v3.0",
  "version_ordinal": 3,
  "previous_version_id": "v2.0",
  "retire_versions": ["v1.0"],       # Stop serving v1
  "data_type": "raster",
  "blob_name": "floods/jakarta/v3.tif"
}
```

### Service Layer URLs (After Above Workflow)

```
/tiles/floods/jakarta/latest  → v3.0 COG (is_latest=TRUE)
/tiles/floods/jakarta/v3.0    → v3.0 COG (is_served=TRUE)
/tiles/floods/jakarta/v2.0    → v2.0 COG (is_served=TRUE)
/tiles/floods/jakarta/v1.0    → 404 Not Found (is_served=FALSE, retired)
/tiles/floods/jakarta/versions → ["v3.0", "v2.0"] (only served versions)
```

---

## References

- [V0.8_DDH_MIGRATION.md](./V0.8_DDH_MIGRATION.md) - Platform refs migration (prerequisite, complete)
- [V0.8_ENTITIES.md](./V0.8_ENTITIES.md) - Entity architecture specification
