# V0.9 Asset Model Redesign — Asset/Release Split

**Created**: 18 FEB 2026
**Updated**: 23 FEB 2026 — IMPLEMENTED in v0.8.22.0–v0.8.24.0
**Status**: IMPLEMENTED — Deployed and QA-verified
**SAFe Type**: Epic (foundational domain model change)
**Deployed**: v0.8.22.0 (schema + core), v0.8.23.0 (ordinal naming), v0.8.24.0 (status restructuring)
**See Also**: V0.9_REVIEW.md (stability assessment + architecture decision record)

---

## 1. Problem Statement

The current `GeospatialAsset` model conflates **identity** (what dataset is this?) with **release** (which version of the data?). This causes three concrete bugs discovered 18 FEB 2026:

### Bug 1: Version-Blind Idempotency

`request_id = SHA256(dataset_id|resource_id)` — no `version_id` in hash for drafts.

After approving v1, resubmitting the same dataset+resource as a new draft returns "already submitted (idempotent)" because the request_id collides with the v1 request.

**Hotfix (V0.8.19.3)**: Return 409 `VersionLifecycleError` when draft resubmit hits an approved asset. Instructs caller to use explicit `version_id`.

### Bug 2: Overwrite Destroys Approved Data

`overwrite=true` on an approved asset went through — created a new draft on top of approved v1, resetting approval state to `pending_review`.

**Hotfix (V0.8.19.3)**: Block `overwrite=true` on approved assets with 409 `OverwriteBlockedError`.

### Bug 3: Identity Mutation

When version_id is assigned at approval time (draft mode), `platform_refs` is mutated:
```
Before approval: {"dataset_id": "X", "resource_id": "Y"}
After approval:  {"dataset_id": "X", "resource_id": "Y", "version_id": "v1"}
```

This changes the asset's identity after creation — the JSONB containment queries that found it by `{dataset_id, resource_id}` still work, but `asset_id` (derived from `platform_refs`) should change too but doesn't. The hash is now inconsistent with its inputs.

---

## 2. Current Model (V0.8)

```
app.geospatial_assets
├── asset_id (PK)         ← SHA256(platform_id|platform_refs_json)[:32]
├── platform_id ("ddh")
├── platform_refs (JSONB)  ← {dataset_id, resource_id, version_id?}
├── lineage_id             ← SHA256(platform_id|nominal_refs_json)[:32]
├── version_ordinal (1,2,3...)
├── previous_asset_id (FK→self)
├── is_latest (bool)
├── is_served (bool)
├── data_type ("raster"|"vector")
├── revision (1,2,3...)    ← overwrite counter
├── current_job_id (FK→jobs)
├── approval_state         ← pending_review|approved|rejected|revoked
├── clearance_state        ← uncleared|ouo|public
├── processing_status      ← pending|processing|completed|failed
├── stac_item_id, stac_collection_id
├── blob_path, table_name
├── ... (audit columns, DAG fields, timestamps)
└── Total: ~40 columns
```

### What Works Well

| Aspect | Assessment |
|--------|-----------|
| Platform-agnostic refs (JSONB) | Good — flexible B2B support |
| Four state dimensions | Good — clean separation of concerns |
| Deterministic IDs | Good concept — but hash inputs are wrong for drafts |
| Lineage tracking | Good — `lineage_id` groups versions correctly |
| Advisory locks | Good — prevents concurrent request races |
| Soft delete + audit trail | Good — REVOKED terminal state works |

### What's Broken

| Issue | Root Cause | Severity |
|-------|-----------|----------|
| Draft resubmit collision | `request_id` hash excludes `version_id` | **High** — blocks QA workflow |
| Overwrite bypasses approval | No approval state guard | **High** — data integrity (hotfixed) |
| Identity mutation at approval | `platform_refs` modified post-creation | **Medium** — inconsistent hash |
| Asset = release conflation | One row = one version = one approval = one blob | **Architectural** — limits lifecycle |
| `revision` vs `version_ordinal` confusion | Two versioning axes (overwrite vs release) | **Medium** — semantic muddle |

---

## 3. Proposed Model: Asset + Release Split

### Core Idea

**Asset** = permanent container for a dataset+resource pair. Identity never changes.
**Release** = a specific version of data under that asset. Has its own lifecycle (processing → approval → clearance).

```
app.assets (NEW — replaces geospatial_assets)
├── asset_id (PK)          ← SHA256(platform_id|dataset_id|resource_id)[:32]
├── platform_id ("ddh")
├── dataset_id (VARCHAR)    ← Promoted from JSONB to column
├── resource_id (VARCHAR)   ← Promoted from JSONB to column
├── data_type ("raster"|"vector")
├── current_release_id (FK→releases)
├── release_count (INT)
├── created_at, updated_at
├── deleted_at, deleted_by  ← Soft delete
└── Total: ~12 columns

app.asset_releases (NEW)
├── release_id (PK)        ← SHA256(asset_id|version_id)[:32]
├── asset_id (FK→assets)
├── version_id (VARCHAR)    ← "v1", "v2", "draft", etc.
├── version_ordinal (INT)
├── is_latest (BOOL)
├── is_served (BOOL)
├── job_id (FK→jobs)        ← Was current_job_id
├── request_id (VARCHAR)    ← Links to api_requests
├── blob_path, table_name
├── stac_item_id, stac_collection_id
├── content_hash
├── approval_state          ← pending_review|approved|rejected|revoked
├── clearance_state         ← uncleared|ouo|public
├── processing_status       ← pending|processing|completed|failed
├── ... (reviewer, timestamps, audit columns)
└── Total: ~30 columns
```

### Key Design Decisions (Confirmed 21 FEB 2026)

| Decision | Rationale |
|----------|-----------|
| `asset_id` = `SHA256(platform_id\|dataset_id\|resource_id)` | Stable — never changes. No version_id in hash. |
| `release_id` = `SHA256(asset_id\|submission_key)` | Deterministic per submission. Draft uses submission timestamp or sequence. |
| `version_id` assigned at approval, not submit | Submitter may *suggest* a version_id, but it isn't official until human approval. Draft releases have `version_id=NULL`. |
| `dataset_id` + `resource_id` promoted to columns | These are **always present** for DDH. No need for JSONB flexibility. |
| `platform_refs` JSONB kept on asset (optional) | For future platforms with different identifiers. DDH doesn't need it. |
| `revision` stays on Release | Overwrite counter *within* a release (re-processing same slot). Not the same as version ordinal. |
| `lineage_id` deleted | Asset IS the lineage. `asset_id` replaces `lineage_id`. |
| `previous_asset_id` → `previous_release_id` | Links between releases, not assets. |
| Multiple releases active simultaneously | v1 and v2 can both be APPROVED. `is_latest` controls `/latest` resolution. |
| Approved releases are immutable | Cannot overwrite an APPROVED release. Must create new release. |
| `overwrite=true` flag kept | Forces explicit user intent when re-processing an existing draft. |
| `AssetRevision` table eliminated | Release IS the revision history. No separate audit table needed. |

### Draft Lifecycle (Solved)

```
1. Submit (no existing draft):
   → Find or create Asset (dataset_id + resource_id)
   → Create Release (version_id=NULL, approval_state=pending_review)
   → Suggested version_id stored as metadata, not identity
   → Job runs, processing completes

2. Approve draft:
   → Reviewer assigns version_id = "v1" (confirms or overrides suggestion)
   → Release.version_id = "v1", Release.ordinal = next ordinal
   → Release.is_latest = true (previous latest flipped to false)
   → STAC materialized to pgSTAC from cached stac_item_json

3. Submit v2 (new draft while v1 still approved):
   → Asset already exists (same dataset_id + resource_id)
   → v1 Release is APPROVED and untouched
   → Create NEW Release (version_id=NULL, draft)
   → No collision — different release_id, v1 stays active

4. Overwrite existing draft:
   → Submit with overwrite=true when draft already exists
   → Same Release row, revision counter increments
   → Old content replaced, processing restarts
   → Cannot overwrite APPROVED release (409 error)

5. Idempotency:
   → Submit without overwrite=true, draft exists and in progress
   → Return existing release (idempotent)
```

### Overwrite vs Release (Clarified 21 FEB 2026)

These were confused in V0.8 because both mutated the same entity row.

**Release** = "here is new data for floods/jakarta" → creates a new Release row. v1 and v2 are different data, different COGs, different STAC items. Both can coexist.

**Overwrite** = "I uploaded the wrong file for this draft, let me fix it" → re-processes the *same* Release. Same slot, new content. Revision counter increments.

```
Asset: floods/jakarta
  ├── Release 1 (v1, approved, immutable)
  │     └── revision 1: original upload
  │
  └── Release 2 (draft, in progress)
        ├── revision 1: uploaded wrong CRS       ← overwrite replaces THIS
        └── revision 2: uploaded corrected file   ← same release, new content
```

Rules:
- `overwrite=true` required for re-processing — explicit user intent
- Can only overwrite draft or rejected releases — approved are immutable
- Submit without existing draft → create new Release
- Submit with existing draft, no overwrite → idempotent return
- Submit with existing draft, overwrite=true → re-process same Release

### URL Resolution Patterns

```
/api/floods/jakarta              → Asset exists? metadata
/api/floods/jakarta/latest       → Release WHERE is_latest=true AND approval_state='approved'
/api/floods/jakarta/v1           → Release WHERE version_id='v1'
/api/floods/jakarta/v2           → Release WHERE version_id='v2'
/api/floods/jakarta/drafts       → Release WHERE version_id IS NULL
/api/floods/jakarta/versions     → All releases ORDER BY ordinal
```

### What This Fixes

| Bug | How It's Fixed |
|-----|---------------|
| Draft resubmit collision | Asset persists across versions. New draft = new Release row. No PK collision. |
| Overwrite destroys approved | Overwrite targets draft Release only; approved Releases immutable. |
| Identity mutation | Asset identity never changes. Release gets version_id at approval. |
| revision vs version_ordinal | `revision` = overwrite counter (within release). `ordinal` = version sequence (across releases). Clear. |
| Revoke-first workflow | Eliminated — drafts coexist with approved versions under same asset. |
| Status lookup by dataset+resource | `SELECT * FROM assets WHERE dataset_id=X AND resource_id=Y` — no JSONB needed. |
| `lineage_id` as separate concept | Asset IS the lineage. `SELECT * FROM releases WHERE asset_id=X ORDER BY ordinal`. |
| 3-tier asset_id fallback | Job FK → release_id directly. No hunting through job params or api_requests. |
| STAC dict on wrong entity | `stac_item_json` on Release, per-version. No cross-version contamination. |
| 10+ mutation methods on single repo | Asset repo: create, soft-delete. Release repo: approve, reject, revoke, update_processing. |

---

## 4. Migration Strategy

### Option A: Big-Bang (Clean Break)

1. Create new tables (`app.assets`, `app.asset_releases`)
2. Migrate data from `app.geospatial_assets`
3. Update all repositories, services, triggers
4. Drop `app.geospatial_assets`

**Pros**: Clean result, no dual-write
**Cons**: Large blast radius, many files change at once
**Effort**: ~5-7 days

### Option B: Incremental (View + Rewrite)

1. Create new tables alongside existing
2. Create a compatibility view that makes new tables look like old
3. Migrate repositories one at a time
4. Drop view and old table when all consumers migrated

**Pros**: Incremental, can deploy partially
**Cons**: View maintenance, two schemas temporarily
**Effort**: ~7-10 days

### Recommendation: Option A

Per CLAUDE.md: "No backward compatibility." All data is dev/test. Clean break is simpler and less error-prone.

---

## 5. Impact Assessment

### Files That Change

| Layer | Files | Nature of Change |
|-------|-------|-----------------|
| **Models** | `core/models/asset.py` | Rewrite: `GeospatialAsset` → `Asset` + `AssetRelease` |
| **Repository** | `infrastructure/asset_repository.py` | Rewrite: queries split across two tables |
| **Service** | `services/asset_service.py` | Rewrite: `assign_version()`, `get_active_asset()`, etc. |
| **Submit** | `triggers/platform/submit.py` | Major: find-or-create Asset, create Release |
| **Status** | `triggers/trigger_platform_status.py` | Medium: join Asset + Release for response |
| **Approval** | `triggers/trigger_approvals.py` | Medium: approve/reject targets Release, not Asset |
| **Unpublish** | `jobs/unpublish_raster.py` | Medium: revoke targets Release |
| **DDL** | `infrastructure/ddl_generator.py` | Minor: new table definitions |
| **Schema** | `infrastructure/schema_manager.py` | Minor: new tables in ensure/rebuild |

### Files That Don't Change

| File | Why |
|------|-----|
| Job/Task models | No asset references |
| STAC layer | Uses `stac_item_id`, not `asset_id` directly |
| Docker worker | Processes tasks, not assets |
| Config | No asset model references |

---

## 6. Relationship to Other V0.9 Work

| V0.9 Doc | Relationship | Ordering |
|----------|-------------|----------|
| **V0.9_PGSTAC.md** | Independent — STAC alignment is catalog layer, this is domain layer | Can proceed in parallel |
| **V0.9_DOCKER.md** | Complete — no interaction | N/A |
| **PYDANTIC_REVIEW.md** | Phase 3-4 cleanup should happen AFTER asset model rewrite | Asset model first |

---

## 7. Open Questions

| # | Question | Decision | Date |
|---|----------|----------|------|
| 1 | Should `platform_refs` JSONB survive on Asset? | **Keep but optional** — `dataset_id`/`resource_id` columns are primary | 18 FEB |
| 2 | What happens to `app.asset_revisions`? | **Eliminated** — Release IS the revision | 21 FEB |
| 3 | Should `request_id` live on Release or stay in `api_requests`? | **On Release** — direct lookup, no join | 18 FEB |
| 4 | Draft naming: `version_id="draft"` or `version_id=NULL`? | **NULL** — matches current behavior, avoids magic string | 18 FEB |
| 5 | Table naming: `app.assets` vs `app.geospatial_assets`? | **`app.assets`** — shorter, `geospatial` is implied | 18 FEB |
| 6 | version_id: assigned at submit or approval? | **Approval** — submitter may suggest, reviewer confirms. Not official until human approval. | 21 FEB |
| 7 | Keep `overwrite=true` flag? | **Yes** — forces explicit user intent. Overwrite = re-process same release, not create new. | 21 FEB |
| 8 | Can multiple releases be active? | **Yes** — v1+v2 both APPROVED simultaneously. `is_latest` controls `/latest` resolution. | 21 FEB |

---

## 8. Immediate Bug Fixes (V0.8.19.3 — Shipped)

These hotfixes are in `triggers/platform/submit.py` (local, pending commit):

1. **Overwrite guard**: If existing asset is `approved`, `overwrite=true` returns 409 `OverwriteBlockedError`
2. **Draft idempotency**: If draft resubmit hits approved asset, returns 409 `VersionLifecycleError` with guidance

These are bandaids — the asset/release split eliminates the root cause.

---

## 9. Implementation Plan (High Level) — COMPLETE

All phases implemented across v0.8.22.0–v0.8.24.0. See `docs/plans/` for detailed execution plans.

### Phase 1: Models — COMPLETE (v0.8.22.0)
- `Asset` and `AssetRelease` Pydantic models in `core/models/asset.py`
- Enums reused: `ApprovalState`, `ClearanceState`, `ProcessingStatus`
- DDL hints for both `app.assets` and `app.asset_releases` tables
- `GeospatialAsset` fully removed

### Phase 2: Repository — COMPLETE (v0.8.22.0)
- Split into `AssetRepository` + `ReleaseRepository` in `infrastructure/`
- All SQL queries migrated to two-table model

### Phase 3: Services — COMPLETE (v0.8.22.0)
- `AssetService` rewritten with `get_or_create_asset()`, `get_or_overwrite_release()`, `approve_release()`
- Submit flow: find-or-create Asset, then create Release
- Approval flow: targets Release, flips `is_latest` atomically

### Phase 4: Triggers + Consumers — COMPLETE (v0.8.23.0–v0.8.24.0)
- Submit trigger: ordinal-based naming finalization (`ord1`, `ord2`)
- Status trigger: clean B2B response with separated concerns
- Approval trigger: Release-targeted approval/reject/revoke
- Auto-detect ID lookup (request_id, job_id, release_id, asset_id)
- `?detail=full` parameter for operational detail

### Phase 5: Migration + Cleanup — COMPLETE (v0.8.22.0)
- Clean-break schema rebuild (no migration needed — dev/test data)
- `GeospatialAsset` model deleted
- Schema manager updated for `app.assets` + `app.asset_releases`

---

## 10. Decisions Log

| # | Decision | Date | Rationale |
|---|----------|------|-----------|
| 1 | Defer to V0.9, hotfix V0.8 | 18 FEB 2026 | Architectural change too large for hotfix |
| 2 | Asset/Release split (not single-table) | 18 FEB 2026 | Eliminates identity mutation, draft collision, version confusion |
| 3 | Clean break migration | 18 FEB 2026 | Dev/test data only, per CLAUDE.md philosophy |
| 4 | version_id assigned at approval, not submit | 21 FEB 2026 | Submitter suggests, reviewer confirms. Not official until human approval. |
| 5 | `overwrite=true` flag retained | 21 FEB 2026 | Explicit user intent for re-processing. Overwrite = same release, new revision. |
| 6 | Multiple active releases allowed | 21 FEB 2026 | v1+v2 coexist. `is_latest` for `/latest` resolution. No revoke-first. |
| 7 | `lineage_id` eliminated | 21 FEB 2026 | Asset IS the lineage. Redundant concept. |
| 8 | `AssetRevision` table eliminated | 21 FEB 2026 | Release IS the revision history. |
| 9 | Schema via rebuild (clean slate) | 21 FEB 2026 | Wipe all data/jobs. No migration needed — rebuild creates new tables. |
| 10 | Ordinal-based naming for drafts | 22 FEB 2026 | `ord1`, `ord2` in table names/STAC IDs. Finalized to `v1`, `v2` at approval. Eliminates `draft` placeholder. |
| 11 | Name finalization in submit trigger | 22 FEB 2026 | Ordinal known after release creation. Translation generates placeholders, submit trigger overwrites with ordinal names. |
| 12 | Status endpoint B2B restructuring | 23 FEB 2026 | Clean separated response: asset/release/outputs/services/approval/versions. Old blob available via `?detail=full`. |
| 13 | Auto-detect ID lookup | 23 FEB 2026 | `/api/platform/status/{id}` tries request_id → job_id → release_id → asset_id. Fixed silent 404 bug. |
