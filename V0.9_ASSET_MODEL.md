# V0.9 Asset Model Redesign — Asset/Release Split

**Created**: 18 FEB 2026
**Status**: ANALYSIS — Architecture Options Ready
**SAFe Type**: Epic (foundational domain model change)
**Depends On**: Immediate bug fixes shipped in V0.8.19.3

---

## 1. Problem Statement

The current `GeospatialAsset` model conflates **identity** (what dataset is this?) with **release** (which version of the data?). This causes three concrete bugs discovered 18 FEB 2026:

### Bug 1: Version-Blind Idempotency

`request_id = SHA256(dataset_id|resource_id)` — no `version_id` in hash for drafts.

After approving v1, resubmitting the same dataset+resource as a new draft returns "already submitted (idempotent)" because the request_id collides with the v1 request.

**Hotfix (V0.8.19.3)**: Return 409 `VersionLifecycleError` when draft resubmit hits an approved asset. Instructs caller to use explicit `version_id`.

### Bug 2: Overwrite Destroys Approved Data

`overwrite=true` on an approved asset went through — created a new draft on top of approved v1, resetting approval state to `pending_review`.

**Hotfix (V0.8.19.3)**: Block `overwrite=true` on approved assets with 409 `OverwriteBlockedError`.

### Bug 3: Identity Mutation

When version_id is assigned at approval time (draft mode), `platform_refs` is mutated:
```
Before approval: {"dataset_id": "X", "resource_id": "Y"}
After approval:  {"dataset_id": "X", "resource_id": "Y", "version_id": "v1"}
```

This changes the asset's identity after creation — the JSONB containment queries that found it by `{dataset_id, resource_id}` still work, but `asset_id` (derived from `platform_refs`) should change too but doesn't. The hash is now inconsistent with its inputs.

---

## 2. Current Model (V0.8)

```
app.geospatial_assets
├── asset_id (PK)         ← SHA256(platform_id|platform_refs_json)[:32]
├── platform_id ("ddh")
├── platform_refs (JSONB)  ← {dataset_id, resource_id, version_id?}
├── lineage_id             ← SHA256(platform_id|nominal_refs_json)[:32]
├── version_ordinal (1,2,3...)
├── previous_asset_id (FK→self)
├── is_latest (bool)
├── is_served (bool)
├── data_type ("raster"|"vector")
├── revision (1,2,3...)    ← overwrite counter
├── current_job_id (FK→jobs)
├── approval_state         ← pending_review|approved|rejected|revoked
├── clearance_state        ← uncleared|ouo|public
├── processing_status      ← pending|processing|completed|failed
├── stac_item_id, stac_collection_id
├── blob_path, table_name
├── ... (audit columns, DAG fields, timestamps)
└── Total: ~40 columns
```

### What Works Well

| Aspect | Assessment |
|--------|-----------|
| Platform-agnostic refs (JSONB) | Good — flexible B2B support |
| Four state dimensions | Good — clean separation of concerns |
| Deterministic IDs | Good concept — but hash inputs are wrong for drafts |
| Lineage tracking | Good — `lineage_id` groups versions correctly |
| Advisory locks | Good — prevents concurrent request races |
| Soft delete + audit trail | Good — REVOKED terminal state works |

### What's Broken

| Issue | Root Cause | Severity |
|-------|-----------|----------|
| Draft resubmit collision | `request_id` hash excludes `version_id` | **High** — blocks QA workflow |
| Overwrite bypasses approval | No approval state guard | **High** — data integrity (hotfixed) |
| Identity mutation at approval | `platform_refs` modified post-creation | **Medium** — inconsistent hash |
| Asset = release conflation | One row = one version = one approval = one blob | **Architectural** — limits lifecycle |
| `revision` vs `version_ordinal` confusion | Two versioning axes (overwrite vs release) | **Medium** — semantic muddle |

---

## 3. Proposed Model: Asset + Release Split

### Core Idea

**Asset** = permanent container for a dataset+resource pair. Identity never changes.
**Release** = a specific version of data under that asset. Has its own lifecycle (processing → approval → clearance).

```
app.assets (NEW — replaces geospatial_assets)
├── asset_id (PK)          ← SHA256(platform_id|dataset_id|resource_id)[:32]
├── platform_id ("ddh")
├── dataset_id (VARCHAR)    ← Promoted from JSONB to column
├── resource_id (VARCHAR)   ← Promoted from JSONB to column
├── data_type ("raster"|"vector")
├── current_release_id (FK→releases)
├── release_count (INT)
├── created_at, updated_at
├── deleted_at, deleted_by  ← Soft delete
└── Total: ~12 columns

app.asset_releases (NEW)
├── release_id (PK)        ← SHA256(asset_id|version_id)[:32]
├── asset_id (FK→assets)
├── version_id (VARCHAR)    ← "v1", "v2", "draft", etc.
├── version_ordinal (INT)
├── is_latest (BOOL)
├── is_served (BOOL)
├── job_id (FK→jobs)        ← Was current_job_id
├── request_id (VARCHAR)    ← Links to api_requests
├── blob_path, table_name
├── stac_item_id, stac_collection_id
├── content_hash
├── approval_state          ← pending_review|approved|rejected|revoked
├── clearance_state         ← uncleared|ouo|public
├── processing_status       ← pending|processing|completed|failed
├── ... (reviewer, timestamps, audit columns)
└── Total: ~30 columns
```

### Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| `asset_id` = `SHA256(platform_id\|dataset_id\|resource_id)` | Stable — never changes. No version_id in hash. |
| `release_id` = `SHA256(asset_id\|version_id)` | Deterministic per version. Draft uses `version_id="draft"`. |
| `dataset_id` + `resource_id` promoted to columns | These are **always present** for DDH. No need for JSONB flexibility. |
| `platform_refs` JSONB kept on asset (optional) | For future platforms with different identifiers. DDH doesn't need it. |
| `revision` column deleted | Overwrite = new release, not in-place mutation. |
| `lineage_id` deleted | Asset IS the lineage. `asset_id` replaces `lineage_id`. |
| `previous_asset_id` → `previous_release_id` | Links between releases, not assets. |

### Draft Lifecycle (Solved)

```
1. Submit (draft):
   → Find or create Asset (dataset_id + resource_id)
   → Create Release (version_id="draft", approval_state=pending_review)
   → release_id = SHA256(asset_id|"draft")
   → request_id = SHA256(dataset_id|resource_id|"draft")

2. Approve draft:
   → Release.version_id = "v1" (or next ordinal)
   → release_id STAYS the same (no identity change)
   → Asset.current_release_id updated

3. Submit v2 (new draft after v1 approved):
   → Asset already exists (same dataset_id + resource_id)
   → Create NEW Release (version_id="draft")
   → Old "draft" release_id was promoted to v1, so no collision
   → request_id = SHA256(dataset_id|resource_id|"draft") — SAME hash, but old request completed

4. Idempotency check:
   → Find request by request_id
   → If existing request is COMPLETED and its release is APPROVED → this is a new workflow, not idempotent
   → If existing request is IN PROGRESS → true idempotent, return existing
```

### What This Fixes

| Bug | How It's Fixed |
|-----|---------------|
| Draft resubmit collision | Asset persists across versions. New draft = new Release row. |
| Overwrite destroys approved | Overwrite creates new Release; approved Release is immutable. |
| Identity mutation | Asset identity never changes. Release gets version_id at approval. |
| revision vs version_ordinal | Only one concept: Release with version_id + ordinal. |
| Status lookup by dataset+resource | `SELECT * FROM assets WHERE dataset_id=X AND resource_id=Y` — no JSONB needed. |

---

## 4. Migration Strategy

### Option A: Big-Bang (Clean Break)

1. Create new tables (`app.assets`, `app.asset_releases`)
2. Migrate data from `app.geospatial_assets`
3. Update all repositories, services, triggers
4. Drop `app.geospatial_assets`

**Pros**: Clean result, no dual-write
**Cons**: Large blast radius, many files change at once
**Effort**: ~5-7 days

### Option B: Incremental (View + Rewrite)

1. Create new tables alongside existing
2. Create a compatibility view that makes new tables look like old
3. Migrate repositories one at a time
4. Drop view and old table when all consumers migrated

**Pros**: Incremental, can deploy partially
**Cons**: View maintenance, two schemas temporarily
**Effort**: ~7-10 days

### Recommendation: Option A

Per CLAUDE.md: "No backward compatibility." All data is dev/test. Clean break is simpler and less error-prone.

---

## 5. Impact Assessment

### Files That Change

| Layer | Files | Nature of Change |
|-------|-------|-----------------|
| **Models** | `core/models/asset.py` | Rewrite: `GeospatialAsset` → `Asset` + `AssetRelease` |
| **Repository** | `infrastructure/asset_repository.py` | Rewrite: queries split across two tables |
| **Service** | `services/asset_service.py` | Rewrite: `assign_version()`, `get_active_asset()`, etc. |
| **Submit** | `triggers/platform/submit.py` | Major: find-or-create Asset, create Release |
| **Status** | `triggers/trigger_platform_status.py` | Medium: join Asset + Release for response |
| **Approval** | `triggers/trigger_approvals.py` | Medium: approve/reject targets Release, not Asset |
| **Unpublish** | `jobs/unpublish_raster.py` | Medium: revoke targets Release |
| **DDL** | `infrastructure/ddl_generator.py` | Minor: new table definitions |
| **Schema** | `infrastructure/schema_manager.py` | Minor: new tables in ensure/rebuild |

### Files That Don't Change

| File | Why |
|------|-----|
| Job/Task models | No asset references |
| STAC layer | Uses `stac_item_id`, not `asset_id` directly |
| Docker worker | Processes tasks, not assets |
| Config | No asset model references |

---

## 6. Relationship to Other V0.9 Work

| V0.9 Doc | Relationship | Ordering |
|----------|-------------|----------|
| **V0.9_PGSTAC.md** | Independent — STAC alignment is catalog layer, this is domain layer | Can proceed in parallel |
| **V0.9_DOCKER.md** | Complete — no interaction | N/A |
| **PYDANTIC_REVIEW.md** | Phase 3-4 cleanup should happen AFTER asset model rewrite | Asset model first |

---

## 7. Open Questions

| # | Question | Options | Recommendation |
|---|----------|---------|----------------|
| 1 | Should `platform_refs` JSONB survive on Asset? | Keep (flexibility) vs Remove (DDH-only) | Keep but optional — `dataset_id`/`resource_id` columns are primary |
| 2 | What happens to `app.asset_revisions`? | Merge into Release model vs Keep separate | Merge — Release IS the revision |
| 3 | Should `request_id` live on Release or stay in `api_requests`? | On Release vs FK | On Release — direct lookup, no join |
| 4 | Draft naming: `version_id="draft"` or `version_id=NULL`? | "draft" string vs NULL | NULL — matches current behavior, avoids magic string |
| 5 | Table naming: `app.assets` vs `app.geospatial_assets`? | Rename vs Keep | `app.assets` — shorter, `geospatial` is implied by the app |

---

## 8. Immediate Bug Fixes (V0.8.19.3 — Shipped)

These hotfixes are in `triggers/platform/submit.py` (local, pending commit):

1. **Overwrite guard**: If existing asset is `approved`, `overwrite=true` returns 409 `OverwriteBlockedError`
2. **Draft idempotency**: If draft resubmit hits approved asset, returns 409 `VersionLifecycleError` with guidance

These are bandaids — the asset/release split eliminates the root cause.

---

## 9. Implementation Plan (High Level)

Detailed task breakdown to be created when work begins.

### Phase 1: Models (Day 1)
- Define `Asset` and `AssetRelease` Pydantic models
- Define enums (reuse existing `ApprovalState`, `ClearanceState`, `ProcessingStatus`)
- Define DDL hints for both tables
- Keep `GeospatialAsset` temporarily for import compatibility

### Phase 2: Repository (Day 2-3)
- `AssetRepository` → split into `AssetRepository` (container) + `ReleaseRepository` (versions)
- Or: single `AssetRepository` with methods for both tables
- Migrate all SQL queries

### Phase 3: Services (Day 3-4)
- `AssetService` rewrite: `create_or_get_asset()`, `create_release()`, `assign_version()`, `approve_release()`
- Submit flow: find-or-create asset, then create release
- Approval flow: target release, update asset.current_release_id

### Phase 4: Triggers + Consumers (Day 4-5)
- Submit, status, approval, unpublish triggers
- Platform catalog service
- Status response builder

### Phase 5: Migration + Cleanup (Day 5-6)
- Data migration script (geospatial_assets → assets + asset_releases)
- Drop old table
- Delete `GeospatialAsset` model
- Update schema manager

---

## 10. Decisions Log

| # | Decision | Date | Rationale |
|---|----------|------|-----------|
| 1 | Defer to V0.9, hotfix V0.8 | 18 FEB 2026 | Architectural change too large for hotfix |
| 2 | Asset/Release split (not single-table) | 18 FEB 2026 | Eliminates identity mutation, draft collision, version confusion |
| 3 | Clean break migration | 18 FEB 2026 | Dev/test data only, per CLAUDE.md philosophy |
