# V0.9 Systemic Stability Review & Architecture Decision

**Date**: 21 FEB 2026
**Version Assessed**: v0.8.20.1
**Overall Rating**: 7.5/10 — Beta-stable, production-risky at scale
**Architecture Decision**: Asset/Release entity split (confirmed 21 FEB 2026)

---

## Part 1: Stability Assessment (v0.8.20.1)

### What's Working Well

- **Error handling**: Three-tier defense for asset creation (create → verify → repair), canonical error log with 40+ documented patterns
- **Race condition mitigation**: PostgreSQL advisory locks, atomic "last task turns out the lights" pattern, idempotent job IDs
- **Configuration**: Comprehensive fail-fast with 40+ env var regex validations, clear 4-mode deployment architecture
- **Dependency security**: Active CVE tracking — geopandas, aiohttp, pillow all patched
- **Deployment**: `deploy.sh` handles versioning, health checks, and version verification automatically
- **Recent bug fixes**: Draft self-conflict (PIP-007), overwrite race (PIP-006), multi-worker competition — all resolved

### Critical Risks (address before heavy load)

| Risk | Impact | Where |
|------|--------|-------|
| **psycopg3 Enum adapter untested** | All asset updates could 500 if ApprovalState/ClearanceState Enums don't serialize | `infrastructure/postgresql.py` |
| **STAC materialization is immutable** | Cached `cog_metadata.stac_item_json` has no re-derivation path; double-approval or corrupted JSON = silent failure | `services/asset_approval_service.py` |
| **3-tier asset fallback** added ad-hoc | asset_id sometimes missing from job record (QA found this 20 FEB); fallback behavior undocumented | `triggers/trigger_approvals.py` |

### Medium Risks (next sprint)

| Risk | Impact | Where |
|------|--------|-------|
| **Zero test coverage** on connection pool, Service Bus validator, AppModeConfig routing | Edge cases will surface in production, not dev | `infrastructure/connection_pool.py`, `startup/service_bus_validator.py`, `config/app_mode_config.py` |
| **AppModeConfig singleton not thread-safe** | Race condition possible in Docker multi-thread startup | `config/app_mode_config.py:517` |
| **Dead queue config** still in routing defaults | `functionapp-tasks` queue removed but referenced; silent task loss if fallback triggers | `config/defaults.py` |
| **QA protocol violations** | dry_run returned 200 on invalid (fixed), geo integrity timer format inconsistent, fragment param without HX-Request header | Multiple triggers |

---

## Part 2: Why the Entity Model Must Change

### The GeoGod Anti-Pattern

`GeospatialAsset` carries ~40 columns across 10 orthogonal concerns: identity, versioning, revision, approval, clearance, revocation audit, processing orchestration, STAC catalog ops, DAG fields, and soft delete. It was designed as a clean Aggregate Root on 29 JAN 2026, but each subsequent feature pulled the entity in a different direction:

| Date | Feature Added | What It Did to the Entity |
|------|--------------|---------------------------|
| 29 JAN | Entity created (~30 cols) | Clean start — identity + approval + clearance |
| 31 JAN | Lineage/versioning (5 cols) | Bolted versioning onto identity row |
| 08 FEB | Revocation audit (3 cols + notes) | Third set of timestamps for approval concern |
| 09 FEB | Approval-aware overwrite validation | Validation scattered across repo, service, trigger |
| 17 FEB | Draft mode + `assign_version()` | **Identity mutation** — platform_refs modified post-creation |
| 19 FEB | STAC materialization at approval | Entity now responsible for catalog lifecycle |
| 20 FEB | Revoke-first workflow | Workaround for single-entity PK collision |

### The Structural Contradiction

The entity conflates two fundamentally different concepts:

1. **The thing** — "floods/jakarta" exists, it's raster data, it belongs to DDH. Stable identity.
2. **A rendering of the thing** — v1 was processed on this date, with this COG, approved by this person, with this STAC item. Mutable lifecycle.

These have different lifecycles. The thing is permanent. The rendering goes through processing → approval → clearance → possible revocation. The bugs from 18-20 FEB weren't edge cases — they were the model telling us it can't be both at once.

### The Smoking Gun: Identity Mutation at `assign_version()`

When a draft gets approved, `version_id` is injected into `platform_refs`:
```
Before: platform_refs = {dataset_id: "X", resource_id: "Y"}
After:  platform_refs = {dataset_id: "X", resource_id: "Y", version_id: "v1"}
```

`asset_id = SHA256(platform_refs)` should change — but it can't, because it's the PK. The hash becomes inconsistent with its inputs. This isn't a bug you can fix within the single-entity model.

### The Revoke-First Workflow Is Infrastructure Leaking

The 409 "Cannot submit new draft while version is approved" exists because draft and approved version would occupy the same PK slot. That's not a business rule — it's a data model constraint leaking into user experience. Users shouldn't need to revoke v1 before they can start working on v2.

### Why `lineage_id` Existing Was the Signal

`lineage_id = SHA256(platform_id|dataset_id|resource_id)` — without version. This groups assets by stable identity. But that's exactly what `asset_id` should have been all along. The fact that a separate lineage concept was needed proves the entity was conflating two things.

---

## Part 3: Architecture Decision — Asset/Release Split

**Decision Date**: 21 FEB 2026
**Status**: CONFIRMED
**Full Specification**: `V0.9_ASSET_MODEL.md`

### The Split

```
Asset (the thing — stable, never mutates after creation)
  asset_id     = SHA256(platform_id | dataset_id | resource_id)  ← STABLE FOREVER
  platform_id  = "ddh"
  dataset_id   = "floods"
  resource_id  = "jakarta"
  data_type    = "raster"
  created_at, updated_at
  deleted_at, deleted_by

Release (a rendering — one per version, owns its own lifecycle)
  release_id    = SHA256(asset_id | submission_key)
  asset_id      = FK → Asset
  version_id    = NULL (draft) | "v1" (assigned at approval)
  ordinal       = 1, 2, 3...

  # Physical outputs
  blob_path, table_name
  stac_item_id, stac_collection_id
  stac_item_json                     ← cached STAC dict lives HERE
  content_hash, source_file_hash

  # Processing
  job_id, processing_status
  processing_started_at, processing_completed_at

  # Approval (per-release, not per-asset)
  approval_state, reviewer, reviewed_at
  clearance_state, adf_run_id
  revoked_at, revoked_by, revocation_reason

  # Version flags
  revision       = overwrite counter within this release
  is_latest      = bool
  is_served      = bool
  created_at, updated_at
```

### Key Decisions (21 FEB 2026)

| Decision | Rationale |
|----------|-----------|
| **version_id assigned at approval** | Submitter may suggest a version_id, but it isn't official until human approval. Draft releases have `version_id=NULL`. |
| **`overwrite=true` flag kept** | Force explicit intent from the user. Overwrite = re-process same release (new revision). No overwrite = create new release. |
| **Multiple releases active simultaneously** | v1 and v2 can both be APPROVED. `is_latest` controls `/latest` resolution. |
| **`lineage_id` eliminated** | Asset IS the lineage. All releases under one `asset_id` ARE the version history. |
| **`AssetRevision` table eliminated** | Release IS the revision history. No separate audit table needed. |
| **Approved releases are immutable** | Cannot overwrite an APPROVED release. Must create new release. |

### URL Resolution Patterns

```
/api/floods/jakarta              → Asset exists? Yes/No
/api/floods/jakarta/latest       → WHERE asset_id=X AND is_latest=true AND approval_state='approved'
/api/floods/jakarta/v1           → WHERE asset_id=X AND version_id='v1'
/api/floods/jakarta/v2           → WHERE asset_id=X AND version_id='v2'
/api/floods/jakarta/drafts       → WHERE asset_id=X AND version_id IS NULL
/api/floods/jakarta/versions     → WHERE asset_id=X ORDER BY ordinal
```

### Overwrite vs Release (Clarified)

This was confused in V0.8 because both mutated the same entity row.

**Release** = "here is new data for floods/jakarta" → creates a new Release row. v1 and v2 are different datasets, different COGs, different STAC items. Both can exist simultaneously.

**Overwrite** = "I uploaded the wrong file for this draft, let me fix it" → re-processes the same Release. Same slot, new content. Revision counter increments, old content replaced.

```
Asset: floods/jakarta
  ├── Release 1 (v1, approved, immutable)
  │     └── revision 1: original upload
  │
  └── Release 2 (draft, in progress)
        ├── revision 1: uploaded wrong CRS       ← overwrite replaces THIS
        └── revision 2: uploaded corrected file   ← same release, new content
```

Rules:
- **Overwrite requires `overwrite=true`** — explicit user intent
- **Can only overwrite draft or rejected releases** — approved releases are immutable
- **No overwrite flag = new release** if no draft exists, or idempotent return if draft in progress
- **Submit without existing draft** → create new Release
- **Submit with existing draft** → idempotent (return existing), or overwrite if `overwrite=true`

### What This Eliminates

| V0.8 Problem | V0.9 Resolution |
|-------------|-----------------|
| `assign_version()` mutates identity | Version lives on Release; Asset identity never changes |
| Revoke-first workflow (409 block) | Draft release coexists with approved releases under same asset |
| 3-tier asset_id fallback in approvals | Job FK points directly at `release_id` |
| STAC dict cached on wrong entity | `stac_item_json` on Release, not shared across versions |
| 10+ mutation methods on one repository | Asset repo: create, soft-delete. Release repo: approve, reject, revoke, update_processing |
| `AssetRevision` as proto-artifact | Replaced entirely by Release history |
| `lineage_id` as separate concept | Asset IS the lineage — `SELECT * FROM releases WHERE asset_id=X ORDER BY ordinal` |
| `revision` vs `version_ordinal` confusion | `revision` = overwrite counter (within release), `ordinal` = version sequence (across releases) |
| Draft → versioned identity collision | Different release_ids, no PK collision, no revoke-first needed |

---

## Part 4: V0.9 Documentation Alignment

### Active V0.9 Documents

| Document | Status | Relationship to Asset/Release |
|----------|--------|-------------------------------|
| **V0.9_ASSET_MODEL.md** | CONFIRMED — master spec | Core specification for the split |
| **V0.9_PGSTAC.md** | ACTIVE — independent parallel | Catalog layer; no dependency on asset model. Coordinate Phase 4 timing. |
| **V0.9_PGSTAC_TODO.md** | IN PROGRESS — Phase 1 complete, Phase 2-4 pending | Phase 4 consumer updates should follow asset model deployment to avoid double-editing triggers |
| **V0.9_REVIEW.md** | THIS DOCUMENT | Stability assessment + architecture decision record |

### Archived

| Document | Archive Location | Reason |
|----------|-----------------|--------|
| **docs_claude/V0.9_DOCKER.md** | `docs/archive/v09_archive_feb2026/` | COMPLETE as of v0.8.19.0 (commit `05a6bff`). All tasks implemented. |

### Implementation Ordering

1. **Asset/Release schema** (V0.9_ASSET_MODEL.md) — deploy new tables, migrate data
2. **PGSTAC Phase 2-3** (V0.9_PGSTAC_TODO.md) — can proceed in parallel, no dependency
3. **PGSTAC Phase 4** (consumer updates) — coordinate with asset model; touches same trigger files
4. **DAG orchestration schema** — builds on Release entity; processing_status, job_id already on Release

The DAG system (future) wires into the Release entity, not the Asset. Each processing run is per-release. The Asset itself doesn't have a "processing status" — its releases do. This means the V0.9 schema is DAG-ready before the DAG orchestrator exists.

---

## Part 5: Remaining Stability Items

These items from the original assessment remain valid regardless of the entity model change:

### Error Handling
- Explicit exception handling in critical paths — CoreMachine has 1,800+ lines of instrumented error handling
- Three-tier defense for asset creation (will simplify with Asset/Release split)
- **Gap**: Progress reporting silently swallows errors (`handler_process_raster_complete.py:122-124`)
- **Gap**: StateManager has 13 bare `except Exception` blocks
- **Gap**: Enum serialization fallback missing (`infrastructure/postgresql.py`)

### Race Conditions (Mitigated)
| Issue | Mechanism | Status |
|-------|-----------|--------|
| Concurrent asset operations | PostgreSQL `pg_advisory_xact_lock` | Active (will carry to Asset/Release) |
| Duplicate stage advancement | Atomic `complete_task_and_check_stage()` | Active |
| Duplicate job creation | SHA256 idempotent job IDs | Active |
| Multi-instance Docker worker | Scaled to capacity=1 | Fixed 23 JAN |

### Dependency Health
| Package | Constraint | Reason |
|---------|-----------|--------|
| `numpy<2` | C-extension ABI compatibility | rasterio, pyarrow, geopandas |
| `pypgstac==0.9.8` | Hard pin to match DB schema 9.8 | Schema mismatch if DB upgraded |
| `psycopg[binary]>=3.1.0` | Major upgrade from psycopg2 | Migration complete v0.8.19.2 |
| `pydantic>=2.0.0` | V2 migration | `json_encoders` deprecated, cleanup pending |
| `geopandas>=1.1.2` | CVE-2025-69662 fix | SQL injection patched |
| `aiohttp>=3.13.3` | CVE-2025-69223 + 5 others | Multiple CVEs patched |
| `pillow>=12.1.1` | CVE-2026-25990 fix | OOB write patched |

### Test Coverage Snapshot
| Layer | Coverage | Risk |
|-------|----------|------|
| Model serialization (Pydantic) | Strong (28 tests) | Low |
| Draft mode transitions | Good (12 tests) | Low |
| SQL generation | Good (17 tests) | Low |
| Config validation (700 lines) | **Zero tests** | High |
| Connection pool (470 lines) | **Zero tests** | High |
| Service Bus lifecycle | **Zero tests** | Medium-High |
| AppMode routing (530 lines) | **Zero tests** | High |
| Web interfaces (15 modules) | **Zero tests** | Medium |

**108 test functions across 22 files, ~4,000 lines** — focused on models and serialization, gaps in infrastructure and config.

### Priority Actions (Non-Entity)
1. **Validate Enum serialization** — smoke test for all Enum subclasses through psycopg3 adapters
2. **Test config and infrastructure layers** — `env_validation.py`, `connection_pool.py`, `app_mode_config.py`
3. **Clean dead queue references** — remove `functionapp-tasks` from routing defaults
4. **Thread-safe AppModeConfig singleton** — add lock around initialization
5. **Orthodox return pattern audit** — verify all handlers return `{"success": bool, "result": {...}}`
