"""
Retrieve tiling plans from PostGIS database

Fetches pre-computed tiling strategies from the geo.tiling_plans table.
These plans are generated by PostGIS functions that divide large rasters
into manageable tiles for parallel processing.

Author: Azure Geospatial ETL Team
Version: 1.0.0
"""
import logging
from typing import Dict, List, Optional
from database_client import DatabaseClient
from logger_setup import get_logger

logger = get_logger(__name__)


class TilingPlanService:
    """Service for retrieving and managing tiling plans from PostGIS"""
    
    def __init__(self):
        """Initialize with database connection"""
        self.db_client = DatabaseClient()
        self.logger = get_logger(self.__class__.__name__)
        
    def get_tiling_plan(self, stac_id: str = None, job_id: str = None) -> Optional[Dict]:
        """
        Retrieve a tiling plan from the database
        
        Args:
            stac_id: STAC item ID for the raster
            job_id: Specific job ID for the tiling plan
            
        Returns:
            Dict containing:
                - job_id: Unique identifier for the plan
                - stac_id: STAC item ID
                - tile_count: Number of tiles
                - tiles: List of tile definitions
                - strategy: Tiling strategy metadata
                - status: Plan status
        """
        try:
            if job_id:
                query = """
                    SELECT job_id, stac_id, tile_count, tiles, strategy, status, created_at
                    FROM geo.tiling_plans
                    WHERE job_id = %s
                    LIMIT 1;
                """
                params = (job_id,)
            elif stac_id:
                query = """
                    SELECT job_id, stac_id, tile_count, tiles, strategy, status, created_at
                    FROM geo.tiling_plans
                    WHERE stac_id = %s
                    ORDER BY created_at DESC
                    LIMIT 1;
                """
                params = (stac_id,)
            else:
                self.logger.error("Either stac_id or job_id must be provided")
                return None
            
            result = self.db_client.execute(query, params)
            
            if result and len(result) > 0:
                row = result[0]
                # Handle dict_row results from psycopg3
                plan = {
                    'job_id': row.get('job_id') if isinstance(row, dict) else row[0],
                    'stac_id': row.get('stac_id') if isinstance(row, dict) else row[1],
                    'tile_count': row.get('tile_count') if isinstance(row, dict) else row[2],
                    'tiles': row.get('tiles', []) if isinstance(row, dict) else (row[3] if isinstance(row[3], list) else []),
                    'strategy': row.get('strategy', {}) if isinstance(row, dict) else (row[4] if isinstance(row[4], dict) else {}),
                    'status': row.get('status') if isinstance(row, dict) else row[5],
                    'created_at': (row.get('created_at').isoformat() if row.get('created_at') else None) if isinstance(row, dict) else (row[6].isoformat() if row[6] else None)
                }
                
                # Process tiles to ensure they have the right format
                processed_tiles = []
                for tile in plan['tiles']:
                    processed_tile = {
                        'tile_id': tile.get('tile_id'),
                        'processing_extent': {
                            'minx': tile.get('minx'),
                            'miny': tile.get('miny'),
                            'maxx': tile.get('maxx'),
                            'maxy': tile.get('maxy')
                        },
                        'row_num': tile.get('row_num'),
                        'col_num': tile.get('col_num'),
                        'width_km': tile.get('width_km'),
                        'height_km': tile.get('height_km')
                    }
                    processed_tiles.append(processed_tile)
                
                plan['tiles'] = processed_tiles
                
                self.logger.info(f"Retrieved tiling plan: {plan['tile_count']} tiles for {plan['stac_id']}")
                return plan
                
            else:
                self.logger.warning(f"No tiling plan found for stac_id={stac_id}, job_id={job_id}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error retrieving tiling plan: {str(e)}")
            return None
    
    def create_tiling_plan(self, stac_id: str, source_file: str, 
                          tile_size_km: float = 10.0) -> Optional[str]:
        """
        Create a new tiling plan for a raster
        
        Args:
            stac_id: STAC item ID for the raster
            source_file: Path to the source raster file
            tile_size_km: Target tile size in kilometers (default 10km)
            
        Returns:
            job_id of the created tiling plan, or None if failed
        """
        try:
            # This would typically call a PostGIS function to generate tiles
            # For now, we'll use existing plans
            self.logger.info(f"Would create tiling plan for {stac_id} with {tile_size_km}km tiles")
            
            # Check if plan already exists
            existing = self.get_tiling_plan(stac_id=stac_id)
            if existing:
                self.logger.info(f"Using existing tiling plan: {existing['job_id']}")
                return existing['job_id']
            
            # In production, this would call PostGIS to generate tiles
            # For example:
            # query = "SELECT geo.create_tiling_plan(%s, %s, %s);"
            # params = (stac_id, source_file, tile_size_km)
            # result = self.db_client.execute_query(query, params)
            
            return None
            
        except Exception as e:
            self.logger.error(f"Error creating tiling plan: {str(e)}")
            return None
    
    def update_plan_status(self, job_id: str, status: str) -> bool:
        """
        Update the status of a tiling plan
        
        Args:
            job_id: The tiling plan job ID
            status: New status ('pending', 'processing', 'completed', 'failed')
            
        Returns:
            True if update successful, False otherwise
        """
        try:
            query = """
                UPDATE geo.tiling_plans
                SET status = %s
                WHERE job_id = %s;
            """
            params = (status, job_id)
            
            self.db_client.execute(query, params)
            self.logger.info(f"Updated tiling plan {job_id} status to {status}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error updating tiling plan status: {str(e)}")
            return False
    
    def get_plan_for_file(self, file_path: str) -> Optional[Dict]:
        """
        Get tiling plan for a specific file path
        
        Args:
            file_path: Path to the raster file (e.g., 'sau08feb2019ps.tif')
            
        Returns:
            Tiling plan dict or None
        """
        try:
            # First, find the STAC item for this file
            query = """
                SELECT id 
                FROM geo.items 
                WHERE properties->>'asset_href' LIKE %s
                   OR properties->>'href' LIKE %s
                   OR id LIKE %s
                LIMIT 1;
            """
            search_pattern = f"%{file_path}%"
            params = (search_pattern, search_pattern, search_pattern)
            
            result = self.db_client.execute(query, params)
            
            if result and len(result) > 0:
                stac_id = result[0][0]
                self.logger.info(f"Found STAC ID {stac_id} for file {file_path}")
                return self.get_tiling_plan(stac_id=stac_id)
            
            # If no STAC item found, try using the known mapping
            if 'sau08feb2019ps' in file_path.lower():
                # This is the known STAC ID for sau08feb2019ps.tif
                return self.get_tiling_plan(stac_id='9688674d025c992478d849c687c40a52')
            
            self.logger.warning(f"No STAC item found for file {file_path}")
            return None
            
        except Exception as e:
            self.logger.error(f"Error getting plan for file: {str(e)}")
            return None